---
title: "Deer Creek Hydrodynamic Model Results"
author: "FlowWest"
date: "April 27, 2018"
output: html_document
---

#Libraries
```{r error=FALSE, warning=FALSE, message=FALSE}
library(tidyverse) #loads readr
library(stringr)
library(lubridate)
library(readxl)
#devtools::install_github("flowwest/hecr")
library(hecr)
#library(dataRetrieval) #(https://github.com/USGS-R/dataRetrieval)
#library(rnoaa)
```

#Calibration  
##Sacramento River  Calbration Results
Graphing profile of lidar-recorded water surface elevation in the Sacramento River with model-derived water surface elevations for two different terrain modifications. One is using 2001 channel bathymetry from Upper Sacramento River Comprehensive Study 1D model cross-sections with interpolation every 1,000 ft. The other using 2013 channel bathymetry collected as part of the Kpota Slough Project. Metadata provided in model tracking document "FlowWestModelTracking_DeerCreek.docx".


Figure 1:  Calibration Results Along Upper Sacramento River Profile, 2001 vs 2013 Bathymetry  
```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}

#date of lidar data collection
lidar_date <- lubridate::mdy(c("10/31/2017")) 

#model calibration results data
sac_lidar_calib <- readxl::read_excel("data-raw/calibration/UpperSac_LidarCalibrationProfiles.xlsx",
                                    na = "NA")
  
#Create Plot
sac_lidar_plot <- sac_lidar_calib %>% 
  ggplot(aes(Station_ft, Elevation_ft, color = Surface)) +
  geom_line() +
  theme_light() +
  scale_color_brewer(type = "qual", palette = "Dark2") +
  scale_y_continuous(limits = c(165, 190),
                     breaks = seq(165, 190, 5),
                     minor_breaks = seq(165, 190, 1)) +
  theme(panel.grid.major = element_line(colour = "grey"),
        text = element_text(size = 12)) +
  labs(x = "Profile Line Station (ft)", 
       y = "Water Surface Elevation (ft-NAVD88)")

ggsave("sac_lidar_calib_plot.jpeg", plot = sac_lidar_plot, device = "jpeg",
       path = 'plots/', width = 6.5, height = 4, units = "in")

sac_lidar_plot 


```

  
##Deer Creek Calibration Results
###October 31, 2017 Lidar   
```{r echo=FALSE, message=FALSE}
#import HDF for existing lidar flow plan
#have to query one level above parent directory to get hdf from model
deer_lidar_calib <- hecr::hec_file("../LowerDeerCreek_2018.p10.hdf")

##import deer creek centerline data table
profile_data <- read_csv(file = "data-raw/profile_points_20181009.csv") 

#extract coordinates of points from deer creek profile data table  
profile_coords <- profile_data %>% 
  select(X, Y) %>%  
  as.matrix()

#use HECR to grab model wse results at profile locations
wse_profile_lidar <- hec_two(hc = deer_lidar_calib, xy = profile_coords, 
                    time_stamp = "2018-02-08 00:00:00") #%>%
  #binding the columns in this way assumes the output comes in the same order
  #as the input. I'm beginning to think this is not the case.
  #waiting for emanuel to confirm
  bind_cols(profile_data) %>% 
  mutate(profile_x = X, profile_y = Y, profile_z = Z, wse_ftnavd88 = values) %>% 
  #select(-values, -X, -Y, -Z, -FID, -OBJECTID, -Node_Descr) %>% 
  mutate(calib_diff = wse_ftnavd88 - profile_z) %>% 
  gather(key = meas_type, value = elevation_ft, profile_z, wse_ftnavd88) %>% 
  #create location lables for the figures as an ordered list to maintain plotting
  #order as shown in "levels"
  mutate(typelabel = factor(if_else(meas_type == "profile_z", 
                                    "Lidar Water Surface",
                                    "Modeled Water Surface"), 
                            levels = c("Lidar Water Surface",
                                       "Modeled Water Surface"),
                            ordered = TRUE)) %>%
  select(datetime, plan_id, hdf_cell_index, River_Stat, profile_x, profile_y, 
         typelabel, elevation_ft, calib_diff)

#generate plot of results
deer_lidar_calib_plot <- wse_profile_lidar %>% 
  ggplot(aes(x = River_Stat, y = elevation_ft, color = typelabel, 
             linetype = typelabel, group = typelabel)) +
  geom_line(size = 0.6) +
  theme_minimal() +
#   scale_y_continuous(limits = c(0, 1500),
#                      breaks = seq(0, 1500, 500),
#                      minor_breaks = seq(0, 1500, 100)) +
#   scale_x_datetime(date_labels = "%b-%Y",
#                    date_minor_breaks = "1 month") +
  scale_color_manual(values = c('#fec44f', 'black')) +
#  scale_color_brewer(type = "seq", palette = "YlGnBu") +
  scale_linetype_manual(values = c(1, 2)) +
  labs(x = 'River Station', y = 'Elevation (ft-NAVD88)') +
#  various style assignments
  theme(panel.grid.major = element_line(colour = "grey65"),
        panel.grid.minor = element_line(colour = "grey70"),
        text = element_text(size = 11),
        legend.position = "bottom",
        legend.direction = "horizontal",
        legend.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "in"),
        # legend.box.margin = margin(t = -10, r = -10, b = 10, l = -10),
        legend.title = element_blank(),
        plot.margin = margin(t = 0.25, r = 0.25, b = 0, l = 0, unit = "in")
        # plot.title = element_text(face = "italic", size = 8)
        )

ggsave("deer_lidar_calib_profile.jpg",
       plot = deer_lidar_calib_plot, device = "jpeg", path = 'plots/', width = 6.5,
       height = 4, units = "in")

deer_lidar_calib_plot


```
  
###March 27, 2018 High Water Mark and Water Surface Elevation

2-year flow calibration from high water mark survey data
```{r echo=FALSE, message=FALSE}
#import HDF for existing march 2018 calibration hydrograph run
#have to query one level above parent directory to get hdf from model
deer_existing_mar2018 <- hecr::hec_file("../LowerDeerCreek_2018.p16.hdf")

#import relevant Q2 data from march 2018 survey event including x,y locations along 
#deer creek model profile from which to query results
hwm_march2018 <- read_csv(file = "data-raw/calib_mar2018points_20181011.csv") %>% 
  #filter data to only high water mark survey
  filter(PointCode == "hwm") 

#Filter and organize data to extract Q2 results
q2_calib_data <- hwm_march2018 %>% 
  #take average of duplicate survey points
  group_by(ProfileM) %>% 
  summarise_if(is.numeric, mean) %>% 
  select(ProfileM, ChLength, hwm_z = Z, RASTERVALU, Hz_Precisi, Vert_Preci, 
         profile_x, profile_y)

#create coordinate matrix for HECR  
q2_calib_coords <- q2_calib_data %>% 
  select(profile_x, profile_y) %>%  
  as.matrix()

#querry model results for all timesteps in run

#select maximum WSE over timeseries at each location

#compare to recorded HWM

#investigate areas with large difference and adjust model or thow out points
#as necessary

```


#Freeboard Analysis
According to the USACE "Operation and Maintenance Manual for Deer Creek," the project has a design flow of 21,000 cfs. This is very close to a 50-year flow, so our model is modeling the 50-year flow at 21,000 cfs. The O&M states that the levees are to provide a freebard of 3 feet during the design flow. This section investigates whether this requirement is being met at project levee locations according to the results of the 2018 2D model. 

Figure 2:    
```{r echo=FALSE, error=FALSE, warning=FALSE, message=FALSE}

#import HDF for existing Q2 through Q50 plan
#have to query one level above parent directory to get hdf from model
deer_existing <- hecr::hec_file("../LowerDeerCreek_2018.p14.hdf")

#import coordinates from which to get results
##from deer creek centerline
profile_data <- read_csv(file = "data-raw/profile_points_20181009.csv") 

profile_coords <- profile_data %>% 
  select(X, Y) %>%  
  as.matrix()

##import data from levees
levee_data <- read_csv(file = "data-raw/levee_points_20181009.csv") %>% 
  mutate(levee_x = X, levee_y = Y, levee_z = Z) %>% 
  select(-X, -Y, -Z, -Node_Descr, -FID, -FID_)

#use HECR to grab model wse results at profile locations
wse_profile_50yr <- hec_two(hc = deer_existing, xy = profile_coords, 
                    time_stamp = "2018-02-12 00:00:00") %>%
  #binding the columns in this way assumes the output comes in the same order
  #as the input. I'm beginning to think this is not the case.
  #waiting for emanuel to confirm
  bind_cols(profile_data) %>% 
  mutate(profile_x = X, profile_y = Y, wse_ftnavd88 = values) %>% 
  select(-values, -X, -Y, -FID, -OBJECTID, -Node_Descr)

#merge the 50-yr wse results and levee elevation results together based on 
#the river station. This code will duplicate rows in the case of multiple matches.
deer_freeboard <- left_join(x = levee_data, y = wse_profile_50yr, by = "River_Stat") %>% 
  mutate(freeboard = levee_z - wse_ftnavd88)

# #select only existing conditions results, calculate levee elevation difference
# #from water surface elevation, and define name based on left bank or right bank
# deer_existing_freeboard <- filter(deer_50yr, plan_id == "existing") %>%  
#   gather(key = side, value = z_diff, lb_diff, rb_diff) %>%
#   mutate(levee_nm = ifelse(stringr::str_detect(side, "lb"), lb_levee_nm, rb_levee_nm)) %>% 
#   mutate(freeboard = factor(ifelse(z_diff >= 3, "pass", "fail"), 
#                             levels = c("pass", "fail"))) %>% 
#   select(xs_id, deer_station, plan_id, wse, levee_nm, z_diff, freeboard) %>% 
#   filter(levee_nm != "na") %>% 
#   filter(!is.na(z_diff))

#  
# #Create Plot
# deer_existing_freeboard_plot <- deer_existing_freeboard %>% 
#   ggplot(aes(levee_nm, z_diff, color = freeboard)) +
#   geom_point(size = 3, alpha = 0.8) +
#   theme_light() +
#   scale_color_manual(values = c('palegreen3', 'palegreen4')) +
#   # scale_y_continuous(limits = c(165, 190),
#   #                    breaks = seq(165, 190, 5),
#   #                    minor_breaks = seq(165, 190, 1)) +
#   theme(panel.grid.major = element_line(colour = "grey"),
#         text = element_text(size = 12),
#         legend.title = element_blank()) +
#   labs(x = "Project Levee ID", 
#        y = "Freeboard (ft)")
# 
# ggsave("deer_existing_freeboard_plot.jpeg", plot = deer_existing_freeboard_plot, 
#        device = "jpeg", path = 'plots/', width = 6.5, height = 4, units = "in")
# 
# readr::write_csv(deer_existing_freeboard, 
#                  "data/deer_existing_freeboard.csv", 
#                  col_names = TRUE)
# 
# deer_existing_freeboard_plot 


```